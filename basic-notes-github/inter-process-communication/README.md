# 进程通信(ipc)

## 共享内存(存储)
### (拿出一块虚拟地址来，映射到相同的物理内存中)分配一块多个进程均可访问的内存，若某个进程修改了共享内存中的数据，其他进程读到的数据也将会改变。
### 共享内存并未提供锁机制，在某一个进程对共享内存进行读写操作时，不会阻止其它进程对它的读写，如果要对共享内存的读/写加锁，可以使用信号灯。

## 管道
### 所谓管道，就是内核里面的一串缓存。从管道的一端写入数据，实际上就是将数据缓存在内核中，另一端读取，即从内核中读取这段数据。
### 基于文件描述符fd[0]、fd[1]管道可以实现父进程与子进程之间的通信
### shell里执行A|B命令的时候，A进程和B进程均为shell创建的进程，A与B之间不存在父子关系。但A和B的父进程都是shell
### 对于管道而言，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，数据通信遵循先进先出原则。
### 缺点：通信方式效率低，发送方必须等待接受方完成接受才能进行下一次通信

## 消息队列
### 消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
### 缺点：1、通信不及时 2、通信内容大小受限制

## 信号量
### 为了防止多进程竞争共享资源，而造成数据错乱，需要信号量来实现保护机制。
### 本质上是一个计数器，用于协调多个进程对共享数据对象的读/写。它不以传送数据为目的，主要是用来保护共享资源(共享内存、消息队列、socket连接池等)，保证共享资源在一个时刻只有一个进程独享。

### 信号量表示资源的数量，控制信号量的方式有两种原子操作：

### 一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
### 另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
### P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

### 信号初始化为 1，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。

### 进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。

### 如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；
### 接着，当进程 A 生产完数据后，执行 V 操作，就会使得信号量变为 0，于是会唤醒阻塞在 P 操作的进程 B；
### 最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。
### 可以发现，信号初始化为 0，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执行。

## 信号
### 对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。 Linux中通过kill -l可以查看所有的信号
### 信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程

## Socket
### 管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了

## 总结
### 由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。