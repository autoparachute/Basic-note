# C++_STL 

### Standard Template Library 标准模板库

容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。



### STL组件

- 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template
- 算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte
- 迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> ,operator++,operator--等指针相关操作予以重载的class template，提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式

STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，可以用它来操作几乎任何数据集合，包括链表，容器和数组



STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效



### 容器分类

#### 序列式容器

每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。vector,Deque,List

#### 关联式容器

元素位置取决于特定的排序准则，和插入顺序无关，通常与元素值相关。Set,Map



# C++_封装、继承、多态

### 封装

- 封装：类是面向对象程序设计语言中的一个概念。类是对某个对象的定义。包含有关对象动作方式的信息，包括它的**名称、方法、属性和事件**。
- 数据成员通常是私有的，成员函数通常有一部分是公有的，一部分是私有的。因为类的公有的函数可以在类外被访问，也称之为**类的接口**。
- 封装特点： 程序更模块化，更易读易写，提升了代码重用到一个更高的层次。保密性和跨平台性

### 继承

- 继承允许依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。
- 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。

### 多态

- 当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
- 静态联编：在编译时期就将函数实现和函数调用关联起来，不管是引用还是指针在编译时期都是Base类的自然调用Base类的TestFunc()。为了避免这种情况，引入了动态多态。 
- 动态联编：通过继承+虚函数来实现的，只有在程序运行期间(非编译期)才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。具体格式就是使用virtual关键字修饰类的成员函数时，指明该函数为虚函数，并且派生类需要重新实现该成员函数，编译器将实现动态绑定。



# C++_重载，重写以及重定义

### 重载

指在同一作用域中允许有多个同名函数，而这些函数的参数列表不同，包括参数个数不同，类型不同，次序不同，需要注意的是返回值相同与否并不影响是否重载。

- 相同的范围
- 函数名字相同
- 参数不同
- 返回值不同

### 重写与重定义

区别就是在写重写的函数是否是虚函数，只有重写了虚函数的才能算作是体现了C++多态性，否则即为重定义

#### 重写

- 不在同一个作用域（分别位于基类和派生类中）
- 函数名字相同
- 参数也相同
- 基类函数必须有**virtual**关键字，不能有statiic
- 返回值相同，否则报错

#### 重定义

- 不在同一个作用域（分别位于基类和派生类中）
- 函数名字相同
- 参数不同，无论有无**virtual**关键字，基类的函数都将被隐藏
- 参数相同，但基类函数没有**virtual**关键字，此时，基类的函数被隐藏
- 返回值可以不同



# C++_虚函数

虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。

虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

https://blog.csdn.net/haoel/article/details/1948051?ops_request_misc=%7B%22request%5Fid%22%3A%22165163538516782248581248%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=165163538516782248581248&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-1948051.142